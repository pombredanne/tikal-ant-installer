/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limiations under the License.
 */

package org.tp23.antinstaller.runtime.exe;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.StringTokenizer;

import org.tp23.antinstaller.InstallException;
import org.tp23.antinstaller.Installer;
import org.tp23.antinstaller.InstallerContext;
import org.tp23.antinstaller.PropertiesFileRenderer;
import org.tp23.antinstaller.input.ConditionalField;
import org.tp23.antinstaller.input.InputField;
import org.tp23.antinstaller.input.OutputField;
import org.tp23.antinstaller.input.PasswordTextInput;
import org.tp23.antinstaller.input.TargetInput;
import org.tp23.antinstaller.input.TargetSelectInput;
import org.tp23.antinstaller.page.Page;
import org.tp23.antinstaller.runtime.VersionHelper;
import org.tp23.antinstaller.runtime.exe.ExecuteRunnerFilter.AbortException;


/**
 * Loads properties from a file of default properties if found.
 * the Installer element should define an attribute
 * loadDefaults with one of the following values.
 * <li>false - do not look for defaults</li>
 * <li>prompt - look for properties and ask if they should be used if found</li>
 * <li>load - look for defaults if found load them</li>
 * <li>prompt-auto - wierd case where installer permits zero user interaction running only from antinstaller-config.xml defaults</li>
 * 
 * N.B. this is not a generic property loader but one specifically for properties files
 * generated by a previous run of an identical installer or one that according to the version
 * number is compatible, see PropertyTask for loading other property sets
 * FIXME i18n for AbortExceptoins
 * @author teknopaul
 *
 */
public class PropertyLoaderFilter implements ExecuteFilter {
	
	private static final ResourceBundle res = ResourceBundle.getBundle("org.tp23.antinstaller.renderer.Res");
	
	public static final String LOAD = "true";
	public static final String PROMPT = "prompt";
	public static final String PROMPT_AUTO = "prompt-auto";
	public static final String FALSE = "false";
    public static final String DEFAULT_PROPERTIES_FILE_PROPERTY = "antinstaller.properties";

    private final String fileNameProperty;

    private int definedPropertiesCount;

    /**
     * Default constructor required for an ExecuteFilter implementation.
     * The default property name given by @see{DEFAULT_PROPERTIES_FILE_PROPERTY}
     * is used with this constructor
     */
    public PropertyLoaderFilter() {
        this( DEFAULT_PROPERTIES_FILE_PROPERTY );
    }

    /**
     * Constructor that allows the name of the property containg the properties file
     * to be specified
     *
     * @param fileNameProperty property containing the name of file
     */
    public PropertyLoaderFilter( final String fileNameProperty ) {
        this.fileNameProperty = fileNameProperty;
    }

    /**
     * Execute the filter action - in this case pre-setting InputField values
     * with values loaded from a properties file (if present)
     *
     * @see org.tp23.antinstaller.runtime.exe.ExecuteFilter
     * @param ctx context data
     * @throws InstallException if an error occurred loading pre-defined properties
     */
    public void exec(InstallerContext ctx) throws InstallException {

		Installer installer = ctx.getInstaller();
		String loadDefaults = installer.getLoadDefaults();
		if(installer.isVerbose()) {
			ctx.log("loadDefaults attribute:" + loadDefaults);
		}
		boolean load = false;
		if(loadDefaults == null || FALSE.equals(loadDefaults)) {
			if(installer.isVerbose()) {
				ctx.log("Not loading defaults");
			}
			return;
		}
		
        ctx.log( "Checking for predefined properties");
        Properties predefinedProps = loadPredefinedProperties( ctx, fileNameProperty );

        definedPropertiesCount = predefinedProps.size();

        boolean foundProps = false;
        if( definedPropertiesCount == 0 ) {
            ctx.log( "No predefined properties");
        }
        else{
        	foundProps = true;
        }

		if( foundProps && PROMPT.equals(loadDefaults) ) {
			load = ctx.getMessageRenderer().prompt(res.getString("promptLoadDefaults"));
		}
		else if( foundProps && PROMPT_AUTO.equals(loadDefaults)) {
			load = ctx.getMessageRenderer().prompt(res.getString("promptLoadDefaults"));
		}
		else if( foundProps && LOAD.equals(loadDefaults) ) {
			load = true;
		}
		
		if( (!foundProps || !load) && 
				ctx.isAutoBuild() && 
				PROMPT.equals(loadDefaults) ) {
			ctx.log( "Cant run -auto install without properties");
			throw new AbortException("Install Aborted: cant load ant.install.properties");
		}

		if(load) {
			if(installer.isVerbose()) {
				ctx.log("Loading defaults");
			}
            
            // version control
            String propertiesVersion = predefinedProps.getProperty(PropertiesFileRenderer.INSTALLER_VERSION_PROPERTY);
            String configVersion = ctx.getInstaller().getVersion();
            if(propertiesVersion != null) {
                VersionHelper helper = new VersionHelper();
                if( ( ! propertiesVersion.equals(configVersion)) && 
                        helper.equalOrHigher(configVersion , propertiesVersion) ) {
                    
                    // let major versions pass but prompt for differences
                    if( (! ctx.isAutoBuild()) && helper.majorVersionCompatible(configVersion , propertiesVersion) ){
                        if( ! ctx.getMessageRenderer().prompt(res.getString("propertiesVersionMismatch")) ){
                            throw new AbortException("Install Aborted: existing configuration is not compatible, config version: " + configVersion);
                        }
                    }
                    else {
                        throw new AbortException("Install Aborted: existing configuration is not compatible, config version: " + configVersion);
                    }
                }
                
            }
            else {
                throw new AbortException("Install Aborted: local ant.install.properties missing config version, must be equal or lower than: " + configVersion);
            }
            // end version control

            Page[] allPages = installer.getPages();
            handleDefaults( ctx, allPages, predefinedProps );

		}
	}

    /*
     * Use the supplied properties to pre-populate the page fields
     */
	private void handleDefaults( InstallerContext ctx, Page[] allPages, Properties props ) throws InstallException {
		for( int i = 0; i < allPages.length; i++ ) {
            OutputField[] fields = allPages[i].getOutputField();
            setInputValues( ctx, allPages[i], fields, props );
        }
    }

    private void setInputValues( InstallerContext ctx, Page page, OutputField[] outputFields, Properties props )
            throws InstallException {
        //Should never happen, but guard against it
        if( outputFields == null ) {
            return;
        }

        // find relevant targets
        String targets = props.getProperty(page.getName() + PropertiesFileRenderer.TARGETS_SUFFIX);
        List targetsList = splitTargets(targets);

        for (int j = 0; j < outputFields.length; j++) {
            OutputField field = outputFields[j];

            if( field instanceof ConditionalField )  {
                ConditionalField condField = (ConditionalField) field;
                setInputValues( ctx, page, condField.getFields(), props );
            }
            else if( field instanceof InputField ) {
                InputField input = (InputField)field;
                String propName = input.getProperty();
                if( props.containsKey( propName ) ) {
                    String value = props.getProperty(propName);

                    if( ctx.getInstaller().isDebug() ) {
                           ctx.log( "Setting " + propName + "=" + value );
                    }

                    input.setDefaultValue(value); // does not evaluate references
                    input.setInputResult(value);
                    input.setEditted( true );

                    if(field instanceof PasswordTextInput) {
                        if(value == null ){
                            ctx.getMessageRenderer().printMessage(res.getString("promptMissingDefaultPassword"));

                        }
                    }

                    // TARGET TYPES
                    if(field instanceof TargetInput) {
                        // Target and SelectTarget
                        TargetInput tgtInput = (TargetInput)field;
                        page.removeTarget(tgtInput.getIdx());
                        // if target was selected
                        if( ! InputField.isFalse(value)) {
                            page.addTarget(tgtInput.getIdx(), tgtInput.getTarget()); // returns the OS specific suffix if relevant
                            // DEBUG
                            if( ! targetsList.contains(tgtInput.getTarget()) ){ 
                                // could be caused by someone trying to copy a file across platforms (not a good idea)
                                ctx.log("Defaults error: targets list for page " + page.getName()
                                        + " should contain a TargetInput that was true");
                            }
                        }
                        else {
                            if(InputField.isTrue( tgtInput.getForce()) ) {
                                String msg = "Defaults error: forced target for page " + page.getName()
                                + " has been removed";
                                ctx.log(msg);
                                throw new InstallException(msg);
                            }
                        }
                    }
                    if(field instanceof TargetSelectInput) {
                        TargetSelectInput tgtInput = (TargetSelectInput)field;
                        page.removeTarget(tgtInput.getIdx());
                        // one target must be selected (what if the page was not shown??)
                        page.addTarget(tgtInput.getIdx(), value);
                    }
                }
            }
            //TODO: Should properties that are present in properties file but which do not appear
            //      as an InputField be set in the ResultContainer so that they can be used by later
            //      "if" conditions? - no other properties should be loaded separately from additional
            //      resource files if there is a requirement for that using an postDisplayTarget - PH
        }

        //Page targets should be handled by the config loader process and indexed correctly
        List pageTargets = page.getTargets(ctx);
        Iterator iter = targetsList.iterator();
        while (iter.hasNext()) {
            String targetPerProps = (String) iter.next();
            if( ! pageTargets.contains(targetPerProps)) {
                ctx.log("Defaults warning: targets list for page " + page.getName()
                        + " should contain " + targetPerProps);
            }
        }

    }

    /**
     * Check if external properties have been loaded
     *
     * @return <code>true</code> if an external properties file was configured and contained
     *       at least one property
     */
    protected boolean isPropertiesLoaded() {
        return (definedPropertiesCount > 0);
    }

    /*
     * Primarily for unit testing
     */
    int getPropertiesFoundCount() {
        return definedPropertiesCount;
    }

    /**
     * Load properties from a properties file if present.
     * The name of the properties file is checked for in the following order.
     * <p>
     * If the parameter fileNamePropertyName is not null:
     * <ul>
     * <li>the environment is checked for an environmentvariable with that name</li>
     * <li>java system properties are checked for a property with that name</li>
     * </ul>
     * If the file name has not been found, or if <code>fileNamePropertyName == null</code>
     * then the default file name is used - @see{org.tp23.antinstaller.PropertiesFileRenderer#PROPERTIES_FILE_NAME}
     *
     * @param context installer context
     * @param fileNamePropertyName name of environment variable or java system property containing the
     *                             name of the properties file to be loaded or <code>null</code>
     * @return properties
     * @throws InstallException if the properties file is missing or an error occurs loading it
     */
    private Properties loadPredefinedProperties( final InstallerContext context,
                                                 final String           fileNamePropertyName )
            throws InstallException {

        Properties contextProps = InstallerContext.getEnvironment();
        String propertiesFileName = null;
        boolean failSilently = true;

        if( fileNamePropertyName != null ) {
            propertiesFileName = contextProps.getProperty( InstallerContext.ENV_PREFIX + fileNamePropertyName );

            if( propertiesFileName == null ) {
                propertiesFileName =
                        contextProps.getProperty( InstallerContext.JAVA_PREFIX + fileNamePropertyName );
            }

            if( propertiesFileName != null ) {
                //Properties have been passed explicitly to installer so must load them
                failSilently = false;
            }
        }

        if( propertiesFileName == null ) {
            propertiesFileName = PropertiesFileRenderer.PROPERTIES_FILE_NAME;
        }

        Properties definedProperties = new Properties( );

        if( propertiesFileName != null ) {
            File definedPropertiesFile = new File( propertiesFileName );
            context.log( "Loading pre-defined properties from file "
                           + definedPropertiesFile.getAbsolutePath());

            //TODO: Support loading properties file from via classloader as a resource
            try {
                FileInputStream istream = new FileInputStream( definedPropertiesFile );
                definedProperties.load( istream );
                istream.close();
            }
            catch( FileNotFoundException fnfExc ) {
                if( !failSilently ) {
                    throw new InstallException( "Defined properties file "
                                                + definedPropertiesFile.getAbsolutePath()
                                                + " doesn't exist" );
                }
            }
            catch( IOException ioExc ) {
                if( !failSilently ) {
                    throw new InstallException( "Unable to read contents of defined properties file "
                                                 + definedPropertiesFile.getAbsolutePath(),
                                                ioExc );
                }
            }

            if( context.getInstaller().isDebug() ) {
                logPropertiesLoaded( context, definedProperties, definedPropertiesFile );
            }

        }

        return definedProperties;
    }


    // Debug - log properties loaded
    private void logPropertiesLoaded( final InstallerContext context,
                                      final Properties properties,
                                      final File propertiesFile ) {
        Iterator iterator = properties.keySet().iterator();
        context.log( "Predefined properties ("
                        + definedPropertiesCount
                        + ") loaded from "
                        + propertiesFile.getAbsolutePath()
                        + "..." );
        while( iterator.hasNext() ) {
            String key = (String) iterator.next();
            context.log( key + "=" + properties.getProperty( key ) );
        }
    }

	/*
	 * Could do a String.split(",") but want to avoid 1.4 specific stuff generally
	 * @param commaSeparated
	 * @return
	 */
	private List splitTargets(String commaSeparated) {
		if(commaSeparated == null) {
			return Collections.EMPTY_LIST;
		}
		StringTokenizer st = new StringTokenizer(commaSeparated, ",");
		List targets = new ArrayList();
		while (st.hasMoreElements()) {
			String element = st.nextToken();
			if(element != null){
				element = element.trim();
				if(element.length() > 0){
					targets.add(element.trim());
				}
			}
		}
		return targets;
	}
}
